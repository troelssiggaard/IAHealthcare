package dk.troelssiggaard.iacontacts.preprocessing;

/**
 * WISDM Server Program http://www.cis.fordham.edu/wisdm/
 *
 * This class holds the results of tuple feature generation from the
 * WisdmFeatureThread. to prevent corruption from concurrency all functions
 * handling arrays copy them member by member to new arrays.
 *
 * @author Jeff Lockhart <a href="mailto:lockhart@cis.fordham.edu">lockhart@cis.fordham.edu</a>
 * @version 2.3.0
 * @date 16 June 2012
 *
 * --------------------------
 * @date 2015
 * NOTE:
 * This file was edited for use in IA Contacts application (Master Thesis) by Troels Siggaard
 * The original work was done by Jeff Lockhart & Jess Timko of the EISDM project research program.
 *
 */

public class TupFeat {

    /**
     * the number of floating point features
     */
    public static final int FeatureCount = 13;

    /**
     * max number of records in a tuple
     * function of window size (10 seconds) and sampling rate (50hz)
     */
    public static final int recordCount = 100; // Note: 10 seconds times 50 hz sampling rate

    /**
     * holds all of the features generated by feature generation in floating
     * point values the order is determined by the feature thread
     */
    private float[] floatFeat = null;

    /**
     * the number of samples in the tuple
     */
    private int count = 0;

    /**
     * first timestamp
     */
    private long time = 0;

    private float[] x = null;
    private float[] y = null;
    private float[] z = null;
    private long[] t = null;

    /**
     * indicates whether the raw values have been set.
     */
    private boolean rawSet = false;

    /**
     * constructor
     * to be called by the server code, which must always have a usrID
     * @param timestamp
     * first time in tuple
     */
    public TupFeat( long timestamp) {
        time = timestamp;
    }

    /**
     * standard toString() function, only includes features
     */
    public String toString(){
        String s = null;

        s += "?,";
        s += time;
        for(int i = 0; i < FeatureCount; i++){
            s += ",";
            s += floatFeat[i];
        }
        s += ";";

        return s;
    }

    /**
     * takes a string generated by the toString() function and returns a tupFeat object
     * @param s
     * @return
     */
    public static TupFeat stringToTup(String s){
        TupFeat t = null;
        String[] values = s.split("[,;]");
        float[] f = new float[FeatureCount];

        t = new TupFeat(Long.parseLong(values[0]) );  // ?

        for(int i = 0; i < FeatureCount; i++){
            f[i] = Float.valueOf(values[i+1]);  // ?
        }

        t.setFeat(f);

        return t;
    }

    /**
     * sets the feature values for this tuple
     *
     * @param f
     * must be in proper order
     */
    public synchronized void setFeat(float[] f) {
        floatFeat = new float[f.length];
        for (int i = 0; i < f.length; i++) {
            floatFeat[i] = f[i];
        }
    }

    /**
     * returns the floating point feature
     *
     * @return
     */
    public synchronized float[] getFeat() {
        return floatFeat;
    }

    /**
     * copies the raw accel data into the tupfeat object
     *
     * @param xi
     * @param yi
     * @param zi
     * @param ti
     */
    public synchronized void setRaw(float[] xi, float[] yi, float[] zi,
                                    long[] ti) {
        x = new float[xi.length];
        y = new float[yi.length];
        z = new float[zi.length];
        t = new long[ti.length];
        for (int i = 0; i < xi.length; i++) {
            x[i] = xi[i];
            y[i] = yi[i];
            z[i] = zi[i];
            t[i] = ti[i];
        }
        setCount(xi.length);
        rawSet = true;
        return;
    }

    /**
     * sets the count, after some out-of-bounds checking
     *
     * @param c
     */
    public synchronized void setCount(int c) {
        if (c < 0) {
            count = 0;
        } else if (c < recordCount) {
            count = c;
        } else {
            count = recordCount;
        }
        return;
    }

    public synchronized int getCount() {
        return count;
    }

    /**
     * copies an array of raw x values out of the tupfeat object
     *
     * @return
     */
    public synchronized float[] getX() {
        float[] xo = new float[x.length];
        for (int i = 0; i < x.length; i++) {
            xo[i] = x[i];
        }
        return xo;
    }

    /**
     * copies an array of y values out of the tupfeat object
     *
     * @return
     */
    public synchronized float[] getY() {
        float[] yo = new float[y.length];
        for (int i = 0; i < y.length; i++) {
            yo[i] = y[i];
        }
        return yo;
    }

    /**
     * copies an array of z values out of the tupfeat object
     *
     * @return
     */
    public synchronized float[] getZ() {
        float[] zo = new float[z.length];
        for (int i = 0; i < z.length; i++) {
            zo[i] = z[i];
        }
        return zo;
    }

    /**
     * copies an array of timestamp values out of a tupfeat object
     *
     * @return
     */
    public synchronized long[] getT() {
        long[] to = new long[t.length];
        for (int i = 0; i < t.length; i++) {
            to[i] = t[i];
        }
        return to;
    }

    /**
     * converts float arrays to double arrays
     * @param f
     * @return
     */
    public static double[] toDoubles(float[] f){
        double[] d = new double[f.length];

        for(int i = 0; i < f.length; i++){
            d[i] = f[i];
        }

        return d;
    }

    /**
     * sets the raw data arrays in the object to null to free memory
     */
    public synchronized void killraw() {
        x = null;
        y = null;
        z = null;
        t = null;
        rawSet = false;
    }

    public synchronized boolean rawIsSet(){
        return rawSet;
    }

}
